This is a sample module to show how to write a separate module against the Mozart VM 2.0.

The following forms of the compiled Oz code are currently supported:

1. The C++ code generated by the [bootstrap compiler](https://github.com/mozart/mozart2-bootcompiler) (this branch).

----

# How it works

The sole purpose of the bootstrap compiler is to get the real Oz-based compiler running. Therefore, the modules provided will only be "just enough", and the module system will not have an extensible interface uncorrelated to the VM itself.

Nevertheless, the library *is* flexible enough to allow us to add an unrelated module without polluting the VM project or require much human intervention.

Writing a native module comes in 5 steps.

1. Write the C++ header and source code to bridge the Mozart VM to the native code
2. Write the Oz source code to bridge the Oz world with the C++ code
3. Combine the Oz source code to `Base.oz`.
4. Generate the meta-data required by the bootstrap compiler
5. Compile everything to an executable.

## The C++ side

Modules in VM 2.0 is vastly different from the [1.4 foreign interface](http://www.mozart-oz.org/documentation/foreign/index.html). Benefiting from C++11, most of the macros can be eliminated. The way to define a module is to create several classes like this in a header file:

```c++
#include <mozartcore.hh>

using mozart::builtins::In;
using mozart::builtins::Out;

struct ModSomething : mozart::builtins::Module
{
    ModSomething() : mozart::builtins::Module("Something") {}

    struct SomeFunction : mozart::builtins::Builtin<SomeFunction>
    {
        SomeFunction() : mozart::builtins::Builtin("someFunction") {}

        OpResult operator()(mozart::VM vm, In in_arg, Out out_arg);
    };

    struct AnotherFunction : mozart::builtins::Builtin<AnotherFunction>
    {
        AnotherFunction() : mozart::builtins::Builtin("anotherFunction") {}

        OpResult operator()(mozart::VM vm, In in_arg, In in_arg_2);
    };
};
```

1. All new modules will inherit from `mozart::builtins::Module`.
2. The default constructor should call the base class, with the name of the module provided as an argument.
3. All functions will be implemented as function objects, inherited from `mozart::builtins::Builtin` with [CRTP](http://en.wikipedia.org/wiki/Curiously_recurring_template_pattern).
4. Again, the default constructor of each function object calls the base class with its name.
5. The real implementation is written in the `operator()`, as expected.

Note the two `using` statements. Because of a defect in the generator, the `in_arg`'s and `out_arg`'s types must be `In` and `Out`, and cannot be qualified.

In 1.4, the mapping from atoms to functions is filled out manually in `oz_init_module()`. In 2.0, this task is done automatically with help of clang/LLVM. But this made compiling the module a 3-step process.

1. Dump the AST of the header file.
2. Parse the AST and generate the module information into a JSON file, which will be read by the bootstrap compiler.
3. Compile the implementation for linking from Oz to C++ code.

The AST of the header file is dumped using clang with the command:

    clang++ -std=c++11 -stdlib=libc++ \
            -I/path/to/mozart2/vm/main \
            -femit-ast \
            -o something.astbi
            something.hh

This `*.astbi` file is then converted to a JSON description using the Mozart VM 2.0's "generator":

    mkdir mvm2.out
    /path/to/mozart2/generator/main/generator \
            builtins \
            something.astbi \
            mvm2.out/

## The Oz side

The bootstrap compiler does not support dynamic linking or importing `*.ozf` files, so the only way to insert Oz code is via embedding or changing the standard library. But even worse, the compiler only recognizes the built-in module import via `Base.oz`. Therefore, the only way to use our extension module is by modifying `Base.oz`.

The `combine_base_oz.py` file provided here is a simple Python script to combine the original `BaseBuilt.oz` and our custom `Base.oz` functor into the same file. 

    ./combine_base_oz.py /path/to/mozart2/lib/base/BaseBuilt.oz CustomBase.oz > Base.out.oz

The definitions of the functors will be put into the global namespace. An example of `CustomBase.oz` is:

    functor
    require
        Boot_Something at 'x-oz://boot/Something'

    prepare
        Something = something(
            some: Boot_Something.someFunction
            another: proc {$ P Q}
               {Boot_Something.anotherFunction Q P}
            end
        )

    end

and an example Oz file using this module would look like:

    local
        L = {Something.some 1}
    in
        {Something.another L nil}
    end

The URL `'x-oz://boot/Something'` refers to the "Something" module, which is the path specified in the `*.hh` file. The built-ins are accessible like a record.

The bootstrap compiler should be invoked and refer to our `Base.oz` and our JSONs, which is simple:

    java /path/to/bootcompiler.jar -m mvm2.out -b Base.out.oz -o Example.out.cc Example.oz

The `mvm2.out` directory, generated by the generator before, contains all JSON files describing the built-ins, where the bootstrap compiler will use to resolve the content of the `'x-oz://boot/Xxxx'` URLs. The `Base.out.oz` contains the base Oz library, and `Example.oz` is the sample Oz code we want to feed.

The result `Example.out.cc` can be compiled to an executable with the usual way.
